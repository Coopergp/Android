---
面试题
---
#### 目录
1. 基础部分
2. 集合
3. 虚拟机
#### 基础部分
1. 谈谈对java多态的理解

2. 抽象类和接口的区别

   抽象类是对事务的抽象，接口是对行为的抽象，抽象类主要侧重于代码复用，接口侧重于解耦；
   抽象类中可以有默认方法，接口中只能有抽象方法；
   一个类只能继承一个抽象类；但是可以实现多个接口。
3. String、StringBuffer和StringBuilder的区别

   - String 为字符串常量，一旦创建不可以被修改，是线程安全的；String 类使用 final 修饰符，不可以被继承；String 的长度是不变的。适用于少量操作的字符串。
   - StringBuffer 为字符串变量，长度是可变的，线程安全。适用于多线程下在字符缓冲区进行大量字符串操作
   - StringBuilder 为字符串变量，长度是可变的，线程不安全。适用于单线程下在字符缓冲区进行大量字符串操作。
字符串操作在执行速度：StringBuilder > StringBuffer > String
4. 说说你对Java反射的理解

5. 说说你对 Java 注解的理解？

   注解，对代码进行注明。使得程序在编译或者运行时，读取到注解并加以处理，以间接的改变程序的运行。
7. 说说你对依赖注入的理解

8. 说一下泛型原理，并举例说明

9. Synchronized与volatile区别

   Synchronized关键字同步方法和代码块，保证了有序性，原子性和可见性；
   volatile修饰变量，保证了可见性和有序性
10. synchronized与reentrantlock实现方式的区别
    1. 使用方式：

       synchronized 是 Java 语言提供的关键字，可以直接在代码中使用，而不需要额外的类或对象。
ReentrantLock 是一个类，位于 java.util.concurrent.locks 包中，需要显式地创建一个 ReentrantLock 对象，并调用其方法来实现同步。
    2. 锁的获取和释放：

       synchronized 关键字会隐式地获取和释放锁，当代码块执行结束或者发生异常时会自动释放锁。
ReentrantLock 则需要手动调用 lock() 方法来获取锁，并在合适的时机调用 unlock() 方法来释放锁，通常使用 try-finally 块来确保锁的释放。
    3. 可中断性：

        ReentrantLock 提供了 lockInterruptibly() 方法，可以在等待锁的过程中响应中断，而 synchronized 关键字在等待锁的过程中无法响应中断。
    4. 公平性：

       ReentrantLock 可以设置为公平锁，即按照请求锁的顺序来获取锁。而 synchronized 关键字是非公平的，它不保证等待锁的线程按照请求锁的顺序来获取锁。
    5. 灵活性：

       ReentrantLock 提供了更多的灵活性，如可以获取锁的持有数、可设置超时时间、可设置为公平锁等功能，而 synchronized 关键字相对简单，不具备这些扩展功能。

       总的来说，synchronized 是更简单、更方便的同步机制，适用于大多数简单的同步需求；而 ReentrantLock 则提供了更多的功能和灵活性，适用于更复杂的同步场景，如需要可中断性、公平性、精确的锁控制等情况。
   
11. 深拷贝与浅拷贝的区别

    浅拷贝，对于基本类型是拷贝的值，对于引用类型拷贝的是内存地址
    深拷贝，是重新开辟了一块内存区域来放置拷贝对象
12. 类加载流程双亲委托机制
    双亲委托机制也就是，当一个类加载器收到类加载请求后，他不会先去加载，而是让它的父加载器先去尝试，层层向上，只有父类无法加载，这时才会尝试让子类去加载，这也就是自己写的为啥无法加载。
13. final、finally与finalize的区别
    1. final：

       final 是 Java 中的关键字，用于修饰类、方法和变量。
修饰类时，表示该类不能被继承，即为最终类。
修饰方法时，表示该方法不能被子类重写，即为最终方法。
修饰变量时，表示该变量只能被赋值一次，即为常量。
    2. finally：

       finally 是 Java 中的关键字，用于定义在 try-catch-finally 结构中的代码块，在异常处理的最后一定会执行，不管是否发生异常。
finally 块通常用于释放资源、关闭文件、断开连接等清理操作，以确保资源被正确释放，无论是否出现异常。
    3. finalize：

       finalize 是 Java 中的方法，是 Object 类的一个方法，在垃圾回收器执行对象回收之前调用。
开发者可以重写 finalize() 方法，用于执行对象释放资源或其他清理操作。然而，应该注意到，由于 finalize 方法的不确定性和不可靠性，不建议过度依赖它来进行资源释放。
在 Java 9 中，finalize() 方法已经被标记为废弃，因为它无法保证及时执行，可能会导致资源泄漏等问题。推荐使用 try-with-resources 语句或者显式调用释放资源的方法来代替 finalize() 方法。
#### 集合
1. ArrayList与LinkedList区别

   ArrayList是基于数组的数据结构，LinkedList是基于链表的数据结构。<br>
   ArrayList适用于查询操作，LinkedList适用于插入和删除操作。
- 为什么LinkedList采用的是双链表而不是单链表
  
  主要原因是双向链表提供了更高效的插入和删除操作。在单链表中，要删除或插入一个节点，需要访问其前驱节点，而访问前驱节点需要从链表头开始遍历链表，这会导致删除和插入操作的时间复杂度为 O(n)，其中 n 是链表的长度
  
2. HashMap与HashTable的区别

   HashMap是非线程安全的；HashTable是线程安全的。<br>
   HashMap允许键和值都为null；HashTable不允许键和值为null
3. 如何解决HashMap的线程安全问题

   
4. LinkedHashMap
   
   查看LinkedHashMap源码发现是继承HashMap实现Map接口。也就是HashMap的方法LinkedMap都有。LinkHashMap与HashMap的主要区别是：LinkedHashMap是有序的，hashmap是无序的。LinkedHashMap通过维护一个双向链表实现有序，也正是因为要维护这个链表，内存上有更大的开销。
#### 虚拟机
1. gc如何判断垃圾对象？哪些可以作为GC Roots

