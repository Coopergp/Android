---
面试题
---
#### 目录
1. 基础部分
2. 集合
3. 虚拟机
#### 基础部分
1. 谈谈对java多态的理解

2. 抽象类和接口的区别

   抽象类是对事务的抽象，接口是对行为的抽象，抽象类主要侧重于代码复用，接口侧重于解耦；
   抽象类中可以有默认方法，接口中只能有抽象方法；
   一个类只能继承一个抽象类；但是可以实现多个接口。
3. String、StringBuffer和StringBuilder的区别

   - String 为字符串常量，一旦创建不可以被修改，是线程安全的；String 类使用 final 修饰符，不可以被继承；String 的长度是不变的。适用于少量操作的字符串。
   - StringBuffer 为字符串变量，长度是可变的，线程安全。适用于多线程下在字符缓冲区进行大量字符串操作
   - StringBuilder 为字符串变量，长度是可变的，线程不安全。适用于单线程下在字符缓冲区进行大量字符串操作。
字符串操作在执行速度：StringBuilder > StringBuffer > String
4. 说说你对Java反射的理解

   反射机制：在运行状态时，动态加载类获取类信息机制
   
   1. 反射的基本步骤
      1. 获取 Class 对象：

         首先需要获取要操作的类的 Class 对象。可以通过类名、对象实例或 Class 类的静态方法来获取 Class 对象。
      
      2. 获取目标信息：

         通过 Class 对象可以获取类的方法、属性、构造方法等信息，以及类的注解、泛型信息等。
      
      3. 构造操作对象：

         根据获取到的方法、属性、构造方法等信息，构造相应的 Method、Field、Constructor 对象，用于后续的操作。
      
      4. 调用目标方法、访问属性或创建对象：

         对于方法调用，通过 Method 对象调用 invoke() 方法来调用方法；对于属性访问，通过 Field 对象的 get() 和 set() 方法来访问属性值；对于对象的创建，通过 Constructor 对象的 newInstance() 方法来创建对象。
      
      5. 处理异常：

         在反射过程中可能会抛出各种异常，需要进行适当的异常处理，确保程序的稳定性和健壮性。

   2. 反射的应用场景

      1. 框架和库：

         框架和库通常需要在运行时动态地加载和调用用户提供的类，这时就需要使用反射来实现动态加载和调用。

      2. 插件化开发：

         在插件化开发中，通常需要动态加载和管理插件中的类和资源，这时可以使用反射来实现动态加载和调用。
         
      3. 序列化和反序列化：

         序列化和反序列化过程中，需要根据类的结构动态地创建对象或读取对象的属性，这时可以使用反射来实现。

      4. 单元测试：

         在单元测试中，通常需要动态地调用被测试类的方法，这时可以使用反射来实现动态调用。
         
6. 说说你对 Java 注解的理解？

   注解，对代码进行注明。使得程序在编译或者运行时，读取到注解并加以处理，以间接的改变程序的运行。
7. 说说你对依赖注入的理解

8. 说一下泛型原理，并举例说明

9. Synchronized与volatile区别

   Synchronized关键字同步方法和代码块，保证了有序性，原子性和可见性；
   volatile修饰变量，保证了可见性和有序性
10. synchronized与reentrantlock实现方式的区别
    1. 使用方式：

       synchronized 是 Java 语言提供的关键字，可以直接在代码中使用，而不需要额外的类或对象。
ReentrantLock 是一个类，位于 java.util.concurrent.locks 包中，需要显式地创建一个 ReentrantLock 对象，并调用其方法来实现同步。
    2. 锁的获取和释放：

       synchronized 关键字会隐式地获取和释放锁，当代码块执行结束或者发生异常时会自动释放锁。
ReentrantLock 则需要手动调用 lock() 方法来获取锁，并在合适的时机调用 unlock() 方法来释放锁，通常使用 try-finally 块来确保锁的释放。
    3. 可中断性：

        ReentrantLock 提供了 lockInterruptibly() 方法，可以在等待锁的过程中响应中断，而 synchronized 关键字在等待锁的过程中无法响应中断。
    4. 公平性：

       ReentrantLock 可以设置为公平锁，即按照请求锁的顺序来获取锁。而 synchronized 关键字是非公平的，它不保证等待锁的线程按照请求锁的顺序来获取锁。
    5. 灵活性：

       ReentrantLock 提供了更多的灵活性，如可以获取锁的持有数、可设置超时时间、可设置为公平锁等功能，而 synchronized 关键字相对简单，不具备这些扩展功能。

       总的来说，synchronized 是更简单、更方便的同步机制，适用于大多数简单的同步需求；而 ReentrantLock 则提供了更多的功能和灵活性，适用于更复杂的同步场景，如需要可中断性、公平性、精确的锁控制等情况。
   
11. 深拷贝与浅拷贝的区别

    浅拷贝，对于基本类型是拷贝的值，对于引用类型拷贝的是内存地址
    深拷贝，是重新开辟了一块内存区域来放置拷贝对象
12. 类加载流程双亲委托机制
    双亲委托机制也就是，当一个类加载器收到类加载请求后，他不会先去加载，而是让它的父加载器先去尝试，层层向上，只有父类无法加载，这时才会尝试让子类去加载，这也就是自己写的为啥无法加载。
13. final、finally与finalize的区别
    1. final：

       final 是 Java 中的关键字，用于修饰类、方法和变量。
修饰类时，表示该类不能被继承，即为最终类。
修饰方法时，表示该方法不能被子类重写，即为最终方法。
修饰变量时，表示该变量只能被赋值一次，即为常量。
    2. finally：

       finally 是 Java 中的关键字，用于定义在 try-catch-finally 结构中的代码块，在异常处理的最后一定会执行，不管是否发生异常。
finally 块通常用于释放资源、关闭文件、断开连接等清理操作，以确保资源被正确释放，无论是否出现异常。
    3. finalize：

       finalize 是 Java 中的方法，是 Object 类的一个方法，在垃圾回收器执行对象回收之前调用。
开发者可以重写 finalize() 方法，用于执行对象释放资源或其他清理操作。然而，应该注意到，由于 finalize 方法的不确定性和不可靠性，不建议过度依赖它来进行资源释放。
在 Java 9 中，finalize() 方法已经被标记为废弃，因为它无法保证及时执行，可能会导致资源泄漏等问题。推荐使用 try-with-resources 语句或者显式调用释放资源的方法来代替 finalize() 方法。

14. 设计模式的六大原则

    1. 单一职责原则（Single Responsibility Principle，SRP）：

       一个类应该只有一个引起变化的原因。换句话说，一个类应该只有一个责任。如果一个类承担了过多的职责，那么这些职责就会耦合在一起，导致变化的风险和维护的困难。

    2. 开放-封闭原则（Open-Closed Principle，OCP）：

       软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着一个实体应该是可扩展的，而不需要修改该实体的源代码。通过继承、接口等方式来实现扩展，而不是直接修改源代码。

    3. 里氏替换原则（Liskov Substitution Principle，LSP）：

       子类必须能够替换掉其父类，并且任何使用父类的地方都应该能够透明地使用子类对象，而不影响程序的正确性。换句话说，子类应该保持父类的行为，但可以有自己的特殊行为。
    4. 接口隔离原则（Interface Segregation Principle，ISP）：

       客户端不应该被强迫依赖于它们不使用的接口。一个类应该只依赖于它需要的接口。接口应该精简，不应该包含客户端不需要的方法。

    5. 依赖倒置原则（Dependency Inversion Principle，DIP）：

       高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。换句话说，应该通过抽象来解耦模块之间的依赖关系。
    
    6.迪米特法则（Law of Demeter，LoD）：

       一个对象应该对其他对象保持最小的了解。换句话说，一个对象不应该直接调用其它对象的内部方法，而应该通过其它对象的接口来进行通信。也就是说，一个对象应该只和它的朋友交流，不和陌生人说话。
#### 集合
1. ArrayList与LinkedList区别

   ArrayList是基于数组的数据结构，LinkedList是基于链表的数据结构。<br>
   ArrayList适用于查询操作，LinkedList适用于插入和删除操作。
- 为什么LinkedList采用的是双链表而不是单链表
  
  主要原因是双向链表提供了更高效的插入和删除操作。在单链表中，要删除或插入一个节点，需要访问其前驱节点，而访问前驱节点需要从链表头开始遍历链表，这会导致删除和插入操作的时间复杂度为 O(n)，其中 n 是链表的长度
  
2. HashMap与HashTable的区别

   HashMap是非线程安全的；HashTable是线程安全的。<br>
   HashMap允许键和值都为null；HashTable不允许键和值为null
3. 如何解决HashMap的线程安全问题

   
4. LinkedHashMap
   
   查看LinkedHashMap源码发现是继承HashMap实现Map接口。也就是HashMap的方法LinkedMap都有。LinkHashMap与HashMap的主要区别是：LinkedHashMap是有序的，hashmap是无序的。LinkedHashMap通过维护一个双向链表实现有序，也正是因为要维护这个链表，内存上有更大的开销。
#### 虚拟机
1. gc如何判断垃圾对象？哪些可以作为GC Roots

