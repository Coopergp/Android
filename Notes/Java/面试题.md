---
面试题
---
#### 目录
1. 基础部分
2. 集合
3. 虚拟机
#### 基础部分
1. 谈谈对java多态的理解

2. 抽象类和接口的区别

   抽象类是对事务的抽象，接口是对行为的抽象，抽象类主要侧重于代码复用，接口侧重于解耦；
   抽象类中可以有默认方法，接口中只能有抽象方法；
   一个类只能继承一个抽象类；但是可以实现多个接口。
3. String、StringBuffer和StringBuilder的区别

   - String 为字符串常量，一旦创建不可以被修改，是线程安全的；String 类使用 final 修饰符，不可以被继承；String 的长度是不变的。适用于少量操作的字符串。
   - StringBuffer 为字符串变量，长度是可变的，线程安全。适用于多线程下在字符缓冲区进行大量字符串操作
   - StringBuilder 为字符串变量，长度是可变的，线程不安全。适用于单线程下在字符缓冲区进行大量字符串操作。
字符串操作在执行速度：StringBuilder > StringBuffer > String
4. 说说你对Java反射的理解

   反射机制：在运行状态时，动态加载类获取类信息机制
   
   1. 反射的基本步骤
      1. 获取 Class 对象：

         首先需要获取要操作的类的 Class 对象。可以通过类名、对象实例或 Class 类的静态方法来获取 Class 对象。
      
      2. 获取目标信息：

         通过 Class 对象可以获取类的方法、属性、构造方法等信息，以及类的注解、泛型信息等。
      
      3. 构造操作对象：

         根据获取到的方法、属性、构造方法等信息，构造相应的 Method、Field、Constructor 对象，用于后续的操作。
      
      4. 调用目标方法、访问属性或创建对象：

         对于方法调用，通过 Method 对象调用 invoke() 方法来调用方法；对于属性访问，通过 Field 对象的 get() 和 set() 方法来访问属性值；对于对象的创建，通过 Constructor 对象的 newInstance() 方法来创建对象。
      
      5. 处理异常：

         在反射过程中可能会抛出各种异常，需要进行适当的异常处理，确保程序的稳定性和健壮性。

   2. 反射的应用场景

      1. 框架和库：

         框架和库通常需要在运行时动态地加载和调用用户提供的类，这时就需要使用反射来实现动态加载和调用。

      2. 插件化开发：

         在插件化开发中，通常需要动态加载和管理插件中的类和资源，这时可以使用反射来实现动态加载和调用。
         
      3. 序列化和反序列化：

         序列化和反序列化过程中，需要根据类的结构动态地创建对象或读取对象的属性，这时可以使用反射来实现。

      4. 单元测试：

         在单元测试中，通常需要动态地调用被测试类的方法，这时可以使用反射来实现动态调用。
         
6. 说说你对 Java 注解的理解？

   注解，对代码进行注明。使得程序在编译或者运行时，读取到注解并加以处理，以间接的改变程序的运行。
7. 说说你对依赖注入的理解

8. 说一下泛型原理，并举例说明

9. 讲讲死锁的发生条件以及如何避免死锁
   1. 互斥条件（Mutual Exclusion）： 至少有一个资源必须处于非共享模式，即一次只能被一个进程使用，如果其他进程请求该资源，必须等待释放。

   2. 占有且等待条件（Hold and Wait）： 进程必须持有至少一个资源，并且在等待获取其他进程持有的资源时，不释放已经占有的资源。

   3. 不可抢占条件（No Preemption）： 资源不能被强制性地从持有它的进程中抢占，只能由持有资源的进程自愿释放。

   4. 循环等待条件（Circular Wait）： 存在一个进程资源的循环等待序列，即进程集合 {P0, P1, …, Pn} 中的 P0 正在等待一个 P1 持有的资源，P1 正在等待 P2 持有的资源，……，Pn-1 正在等待 Pn 持有的资源，而 Pn 又在等待 P0 持有的资源，形成一个循环等待的链。

   为避免死锁，可以采取以下几种策略：

   1. 破坏互斥条件： 尽可能减少使用独占资源，将其转换为共享资源，这样多个线程可以同时访问资源，避免发生互斥条件。

   2. 破坏占有且等待条件： 要求一个线程在获取所有需要的资源之前释放已经持有的资源，或者一次性申请所有需要的资源，避免持有部分资源而等待其他资源的情况。

   3. 破坏不可抢占条件： 允许操作系统在必要时抢占某些资源，从而使资源得到释放，避免死锁的发生。

   4. 破坏循环等待条件： 对资源进行编号，并且规定所有线程只能按照编号递增的顺序申请资源，这样就不会形成循环等待的情况。

   5. 使用资源分配图（Resource Allocation Graph）： 使用资源分配图来检测死锁，并且通过安全序列的判断来避免死锁的发生。

   6. 设置超时时间： 在获取资源时设置超时时间，如果超过一定时间还未获取到资源，就放弃等待并释放已经持有的资源，避免长时间等待导致死锁。

10. Synchronized与volatile区别

    Synchronized关键字同步方法和代码块，保证了有序性，原子性和可见性；
    volatile修饰变量，保证了可见性和有序性
   
11. synchronized与reentrantlock实现方式的区别
    
    1. 使用方式：

       synchronized 是 Java 语言提供的关键字，可以直接在代码中使用，而不需要额外的类或对象。
ReentrantLock 是一个类，位于 java.util.concurrent.locks 包中，需要显式地创建一个 ReentrantLock 对象，并调用其方法来实现同步。
    2. 锁的获取和释放：

       synchronized 关键字会隐式地获取和释放锁，当代码块执行结束或者发生异常时会自动释放锁。
ReentrantLock 则需要手动调用 lock() 方法来获取锁，并在合适的时机调用 unlock() 方法来释放锁，通常使用 try-finally 块来确保锁的释放。
    3. 可中断性：

        ReentrantLock 提供了 lockInterruptibly() 方法，可以在等待锁的过程中响应中断，而 synchronized 关键字在等待锁的过程中无法响应中断。
    4. 公平性：

       ReentrantLock 可以设置为公平锁，即按照请求锁的顺序来获取锁。而 synchronized 关键字是非公平的，它不保证等待锁的线程按照请求锁的顺序来获取锁。
    5. 灵活性：

       ReentrantLock 提供了更多的灵活性，如可以获取锁的持有数、可设置超时时间、可设置为公平锁等功能，而 synchronized 关键字相对简单，不具备这些扩展功能。

       总的来说，synchronized 是更简单、更方便的同步机制，适用于大多数简单的同步需求；而 ReentrantLock 则提供了更多的功能和灵活性，适用于更复杂的同步场景，如需要可中断性、公平性、精确的锁控制等情况。
   
12. 深拷贝与浅拷贝的区别

    浅拷贝，对于基本类型是拷贝的值，对于引用类型拷贝的是内存地址
    深拷贝，是重新开辟了一块内存区域来放置拷贝对象
13. 类加载流程双亲委托机制
    双亲委托机制也就是，当一个类加载器收到类加载请求后，他不会先去加载，而是让它的父加载器先去尝试，层层向上，只有父类无法加载，这时才会尝试让子类去加载，这也就是自己写的为啥无法加载。
14. final、finally与finalize的区别
    1. final：

       final 是 Java 中的关键字，用于修饰类、方法和变量。
修饰类时，表示该类不能被继承，即为最终类。
修饰方法时，表示该方法不能被子类重写，即为最终方法。
修饰变量时，表示该变量只能被赋值一次，即为常量。
    2. finally：

       finally 是 Java 中的关键字，用于定义在 try-catch-finally 结构中的代码块，在异常处理的最后一定会执行，不管是否发生异常。
finally 块通常用于释放资源、关闭文件、断开连接等清理操作，以确保资源被正确释放，无论是否出现异常。
    3. finalize：

       finalize 是 Java 中的方法，是 Object 类的一个方法，在垃圾回收器执行对象回收之前调用。
开发者可以重写 finalize() 方法，用于执行对象释放资源或其他清理操作。然而，应该注意到，由于 finalize 方法的不确定性和不可靠性，不建议过度依赖它来进行资源释放。
在 Java 9 中，finalize() 方法已经被标记为废弃，因为它无法保证及时执行，可能会导致资源泄漏等问题。推荐使用 try-with-resources 语句或者显式调用释放资源的方法来代替 finalize() 方法。

15. 设计模式的六大原则

    1. 单一职责原则（Single Responsibility Principle，SRP）：

       一个类应该只有一个引起变化的原因。换句话说，一个类应该只有一个责任。如果一个类承担了过多的职责，那么这些职责就会耦合在一起，导致变化的风险和维护的困难。

    2. 开放-封闭原则（Open-Closed Principle，OCP）：

       软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着一个实体应该是可扩展的，而不需要修改该实体的源代码。通过继承、接口等方式来实现扩展，而不是直接修改源代码。

    3. 里氏替换原则（Liskov Substitution Principle，LSP）：

       子类必须能够替换掉其父类，并且任何使用父类的地方都应该能够透明地使用子类对象，而不影响程序的正确性。换句话说，子类应该保持父类的行为，但可以有自己的特殊行为。
    4. 接口隔离原则（Interface Segregation Principle，ISP）：

       客户端不应该被强迫依赖于它们不使用的接口。一个类应该只依赖于它需要的接口。接口应该精简，不应该包含客户端不需要的方法。

    5. 依赖倒置原则（Dependency Inversion Principle，DIP）：

       高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。换句话说，应该通过抽象来解耦模块之间的依赖关系。
    
    6.迪米特法则（Law of Demeter，LoD）：

       一个对象应该对其他对象保持最小的了解。换句话说，一个对象不应该直接调用其它对象的内部方法，而应该通过其它对象的接口来进行通信。也就是说，一个对象应该只和它的朋友交流，不和陌生人说话。
16. 线程阻塞的原因

    阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。
线程阻塞分为三种情况：

    - 等待阻塞： Object.wait()，使线程让出cpu执行权，且释放锁。JVM会把该线程放入等待队列中。
    - 同步阻塞：lock，running中的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线
程放入锁池(lock pool)中。
    - 其他阻塞：Sleep/join
        - 线程休眠：Thread.sleep (long millis)方法，使该线程让出cpu执行权，但不释放锁。线程转到阻塞状态。millis结束后直接进入就绪状态。
        - I/O请求： 当发生IO请求时，可能会在读写端都有可能发生IO阻塞。
        - suspend/resume （没用过）
          很多文章都说yield()也是阻塞的一种，其实是不准确的，yield() 可以使的当前线程放弃cpu分得的时间片，但没有经过阻塞状态。切记，这个差别很重要。
#### 集合
1. ArrayList与LinkedList区别

   ArrayList是基于数组的数据结构，LinkedList是基于链表的数据结构。<br>
   ArrayList适用于查询操作，LinkedList适用于插入和删除操作。
- 为什么LinkedList采用的是双链表而不是单链表
  
  主要原因是双向链表提供了更高效的插入和删除操作。在单链表中，要删除或插入一个节点，需要访问其前驱节点，而访问前驱节点需要从链表头开始遍历链表，这会导致删除和插入操作的时间复杂度为 O(n)，其中 n 是链表的长度
  
2. HashMap与HashTable的区别

   HashMap是非线程安全的；HashTable是线程安全的。<br>
   HashMap允许键和值都为null；HashTable不允许键和值为null
3. 如何解决HashMap的线程安全问题

   
4. LinkedHashMap
   
   查看LinkedHashMap源码发现是继承HashMap实现Map接口。也就是HashMap的方法LinkedMap都有。LinkHashMap与HashMap的主要区别是：LinkedHashMap是有序的，hashmap是无序的。LinkedHashMap通过维护一个双向链表实现有序，也正是因为要维护这个链表，内存上有更大的开销。
#### 虚拟机
1. gc如何判断垃圾对象？哪些可以作为GC Roots

2. 什么是强引用、软引用、弱引用和虚引用以及它们之间区别
   1. 强引用（Strong Reference）：

      强引用是最常见的引用类型，它指向一个对象并阻止该对象被垃圾回收。
只要强引用存在，垃圾回收器就不会回收被引用的对象。
示例：Object obj = new Object();

   2. 软引用（Soft Reference）：

      软引用是一种相对强引用更弱的引用类型。当系统内存不足时，垃圾回收器可能会回收被软引用指向的对象。
主要用于实现内存敏感的缓存，在内存不足时可以自动释放缓存中的对象。
示例：SoftReference<Object> softRef = new SoftReference<>(new Object());

   3. 弱引用（Weak Reference）：

      弱引用也是一种相对强引用更弱的引用类型，但是比软引用更弱，只能生存到下一次垃圾回收发生之前。
当对象只被弱引用指向时，垃圾回收器会立即回收该对象。
主要用于避免内存泄漏，例如实现缓存或监听器模式。
示例：WeakReference<Object> weakRef = new WeakReference<>(new Object());

   4. 虚引用（Phantom Reference）：

      虚引用是一种最弱的引用类型，它几乎没有引用价值，主要用于在对象被回收之前收到通知。
虚引用必须与引用队列（ReferenceQueue）一起使用，当虚引用所引用的对象被垃圾回收器回收时，会将虚引用添加到引用队列中。
虚引用的主要作用是跟踪对象被垃圾回收的状态，允许在对象被销毁之前执行一些清理操作。
示例：PhantomReference<Object> phantomRef = new PhantomReference<>(new Object(), referenceQueue);

